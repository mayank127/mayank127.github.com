<html><head><title> A CS296 Group 11 Project Report</title><style type="text/css">h1{text-align:center;} img{display:inline-block;margin: 0 auto;height:500px;}</style></head><body><h1>Introduction</h1><p>Purpose of this report is to analyze the graphs which were produced to show the relation between step time, loop time, velocity update time, position update time, collision time and the no. of iterations and re-runs.</p><h1>Graph 1</h1><img src="../plots/1.png"/><img src="../plots/load_1.png"/><p>In graphs shown above, we have average step time values and total loop time value over all reruns versus iteration value graph. Left side graph is obtained when program is executed with low CPU load and right side graph is obtained when CPU load is high.<br><br> As expected, loop time increases with iteration value since with increasing number of iteration total calculations also increases. Also, the slope of graph decreases when iteration value is around 90.By running the simulation using single step we see that at the 90th step the pendulum which is initially in air collides with the ball and rebounds. At this point the pendulum starts going back and balls start moving, therefore the chances of expected collision increase as relative velocity of ball w.r.t. platform is away from platform. Therefore the time taken in analysing collision decreases and hence total time taken decreases. So the slope decreases at 90th iteration.<br><br>From the graph we can observe that the average step time value continuously decreases. It might be because the simulation takes more time at initial steps than at later steps so the average is high initially but after the number of steps increases time decreases. This may happen because when more no. of iteration occurs, CPU might prioritise the program, thus helping in the faster execution. Also Box2D looks for the collision when objects have approaching velocity between them. Therefore, after the collision of sphere and plank approaching velocity becomes negative and rest other things remain same, which results in less time taken for collision analysis and hence resulting in decreased step time.<br><br>If we do the same experiment with increased load on the CPU and memory then the shape of the graph is almost similar but values of average time increases by some factor proportional to load.<br></p><h1>Graph 2</h1><img src="../plots/2.png"/><img src="../plots/load_2.png"/><p>In graphs shown above. we have step times, collision detection times, velocity update times and position update times averaged over all reruns versus iteration value of graph.Left side graph is obtained when program is executed with low CPU load and right side graph is obtained when CPU load is high.<br><br>As observed from Graph 1 average step time decreases continuously with Iteration value.But the average collision detection times, velocity update times and position update times remains almost constant. Since they only depend on number of steps in simulation and in calculation we have averaged them with the iteration value i.e. number of steps so they remain constant.<br><br>When load is increased time increases by some factor proportional to load, which is expected as the program will be executed slower. <br></p><h1>Graph 3</h1><img src="../plots/3.png"/><img src="../plots/load_3.png"/><p>In graph 3 we have average step time values and total loop time value over all iterations versus rerun value graph.We expect both the values to be almost constant with respect to the number of rerun since time of program only depends on iteration value i.e. number of steps and since we averaged it over all iteration value, so values are constant only depending on CPU condition at which rerun is performed.So when we increase the load it increases the time values according to the load and otherwise it is almost constant. There are some errorneous points due to change in load value in between the running time.<br></p><h1>Graph 4</h1><img src="../plots/4.png"/><img src="../plots/load_4.png"/><p>In graph 4 we have step times, collision detection times, velocity update times and position update times averaged over all iterations versus rerun value of graph. We expect all the values to be constant with respect to the number of rerun since as mentioned above time of program only depends on iteration value i.e. number of steps and we averaged it over all iteration value, so values are constant only depending on CPU condition at which rerun is performed.So when we increase the load it increases the time values according to the load and otherwise it is almost constant.<br></p><h1>Graph 5</h1><img src="../plots/5.png"/><img src="../plots/load_5.png"/><p>In graph 5 we have step time values with error bars according to value at different reruns versus Iteration value.In most of the cases the error bar is small as there is not much change in values at different reruns of the same iteration value. But at some values error is large it may be due to CPU allocation at some  rerun of that iteration. Because of CPU processing error bars at some points is large. With increased load the error bar values also magnifies as the time values also increases. But if we see the relative error it is almost the same with some exceptions due to CPU performance.<br></p><h1>Graph 6</h1><img src="../plots/6.png"/><img src="../plots/load_6.png"/><p>In graph 6 we have for a given iteration value frequency and cumulative frequency of reruns with respect to step timeFrom this graph we can see that most of the reruns occur within some range of steptime and than there are small blocks due to error and CPU processing. Cumulative frequency as expected adds up to 100.With increased load the distribution of rerun over step time increases i.e. error increases but most of reruns occur in same range of step time.<br></p></body></html>